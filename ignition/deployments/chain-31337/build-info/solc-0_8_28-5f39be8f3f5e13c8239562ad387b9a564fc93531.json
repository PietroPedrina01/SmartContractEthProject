{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5f39be8f3f5e13c8239562ad387b9a564fc93531",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/StudentFactory.sol": "project/contracts/StudentFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/StudentCareer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract StudentCareer {\n    // Enum per gestire lo stato di un esame\n    enum ExamStatus {\n        NON_EXISTENT,\n        PENDING,\n        REGISTERED,\n        REJECTED\n    }\n\n    struct Exam {\n        string name;\n        uint8 grade;\n        uint8 credits;\n        uint256 date;\n        ExamStatus status;\n    }\n\n    address public immutable _factory;\n    address public immutable _studentAddress;\n\n    // Lista pubblica di esami\n    Exam[] public _exams;\n\n    uint256 public _totalCredits;\n    bool public _isGraduated;\n    uint256 public _finalAverage;\n    uint256 public _finalGrade;\n    bool public _hasHonors;\n\n    event ExamProposed(\n        string subject,\n        uint8 grade,\n        uint8 credits,\n        uint256 date\n    );\n    event ExamAccepted(\n        string subject,\n        uint8 grade,\n        uint8 credits,\n        uint256 date\n    );\n    event ExamRejected(\n        string subject,\n        uint8 grade,\n        uint8 credits,\n        uint256 date\n    );\n    event StudentGraduated(uint256 date);\n    event FinalGradeSet(uint256 finalGrade, bool hasHonors);\n\n    modifier onlyFactory() {\n        require(msg.sender == _factory, \"Only factory allowed\");\n        _;\n    }\n\n    modifier onlyStudent() {\n        require(msg.sender == _studentAddress, \"Only student allowed\");\n        _;\n    }\n\n    modifier activeCareer() {\n        require(!_isGraduated, \"Already graduated\");\n        _;\n    }\n\n    constructor(address studentAddress) {\n        _factory = msg.sender;\n        _studentAddress = studentAddress;\n    }\n\n    // Il professore (tramite Factory) PROPONE il voto\n    function proposeExam(\n        string memory name,\n        uint8 grade,\n        uint8 credits\n    ) external onlyFactory activeCareer {\n        require(grade >= 18 && grade <= 31, \"Invalid grade\");\n        require(credits > 0, \"Credits must be positive\");\n\n        uint256 ts = block.timestamp;\n\n        _exams.push(\n            Exam({\n                name: name,\n                grade: grade,\n                credits: credits,\n                date: ts,\n                status: ExamStatus.PENDING\n            })\n        );\n\n        emit ExamProposed(name, grade, credits, ts);\n    }\n\n    // Lo studente ACCETTA il voto (Interazione diretta Studente -> Contratto)\n    function acceptGrade(uint256 examIndex) external onlyStudent activeCareer {\n        require(examIndex < _exams.length, \"Exam index out of bounds\");\n        Exam storage e = _exams[examIndex];\n\n        require(e.status == ExamStatus.PENDING, \"Exam not pending\");\n\n        e.status = ExamStatus.REGISTERED;\n        _totalCredits += e.credits;\n\n        emit ExamAccepted(e.name, e.grade, e.credits, block.timestamp);\n    }\n\n    // Lo studente RIFIUTA il voto\n    function rejectGrade(uint256 examIndex) external onlyStudent activeCareer {\n        require(examIndex < _exams.length, \"Exam index out of bounds\");\n        Exam storage e = _exams[examIndex];\n\n        require(e.status == ExamStatus.PENDING, \"Exam not pending\");\n\n        // Se rifiuta, lo stato diventa REJECTED e non si aggiungono crediti\n        e.status = ExamStatus.REJECTED;\n\n        emit ExamRejected(e.name, e.grade, e.grade, block.timestamp);\n    }\n\n    // Calcola la media pesata moltiplicata per 100 per mantenere 2 decimali\n    // Esempio per il problema del floating-point imprecision (faccio prima la moltiplicazione e poi la divisione)\n    function calculateAverage() public view returns (uint256) {\n        uint256 totalWeightedGrades = 0;\n        uint256 registeredCredits = 0;\n\n        for (uint256 i = 0; i < _exams.length; i++) {\n            if (_exams[i].status == ExamStatus.REGISTERED) {\n                totalWeightedGrades +=\n                    uint256(_exams[i].grade) *\n                    uint256(_exams[i].credits);\n                registeredCredits += uint256(_exams[i].credits);\n            }\n        }\n\n        // Evita la divisione per 0\n        if (registeredCredits == 0) return 0;\n\n        return (totalWeightedGrades * 100) / registeredCredits;\n    }\n\n    // Calcolo della laurea\n    function graduate() external onlyStudent activeCareer {\n        require(_totalCredits >= 180, \"Not enough credits to graduate\");\n\n        // Salviamo la media al momento della laurea\n        _finalAverage = calculateAverage();\n        _finalGrade = (_finalAverage * 110) / 30;\n\n        // Il controllo if (_finalGrade < 6600) _finalGrade = 6600; non è necessario perché non è possibile una media sotto il 18\n\n        if (_finalGrade > 11000) {\n            _finalGrade = 11000; // Limitiamo a 110\n            _hasHonors = true; // Se supera 110, assegniamo la lode\n        }\n        _isGraduated = true;\n\n        emit StudentGraduated(block.timestamp);\n        emit FinalGradeSet(_finalGrade, _hasHonors);\n    }\n\n    function getExams() external view returns (Exam[] memory) {\n        return _exams;\n    }\n}\n"
      },
      "project/contracts/StudentFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./StudentCareer.sol\";\n\ncontract StudentFactory {\n    address public immutable _owner;\n    mapping(address => address) public _studentToContract;\n    address[] public _allCareers;\n\n    event CareerCreated(address indexed student, address contractAddress);\n    event GradeProposed(\n        address indexed student,\n        string subject,\n        uint8 grade,\n        uint8 credits\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Only owner allowed\");\n        _;\n    }\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    // Creazione della carriera di uno studente\n    function createCareer(address student) external onlyOwner {\n        require(\n            _studentToContract[student] == address(0),\n            \"Career already exists\"\n        );\n\n        StudentCareer newCareer = new StudentCareer(student);\n        address careerAddr = address(newCareer);\n\n        _studentToContract[student] = careerAddr;\n        _allCareers.push(careerAddr);\n\n        emit CareerCreated(student, careerAddr);\n    }\n\n    // Il professore PROPONE il voto richiamando StudentCareer\n    function proposeGrade(\n        address student,\n        string calldata subject,\n        uint8 grade,\n        uint8 credits\n    ) external onlyOwner {\n        address careerAddress = _studentToContract[student];\n        require(careerAddress != address(0), \"Student not found\");\n\n        // Chiamiamo la funzione di proposta, non di registrazione diretta\n        StudentCareer(careerAddress).proposeExam(subject, grade, credits);\n\n        emit GradeProposed(student, subject, grade, credits);\n    }\n\n    // Helper per il frontend/script\n    function getCareerAddress(address student) external view returns (address) {\n        return _studentToContract[student];\n    }\n}\n"
      }
    }
  }
}