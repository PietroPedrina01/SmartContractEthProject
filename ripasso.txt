# Sample Hardhat 3 Beta Project (`node:test` and `viem`)

This project showcases a Hardhat 3 Beta project using the native Node.js test runner (`node:test`) and the `viem` library for Ethereum interactions.

To learn more about the Hardhat 3 Beta, please visit the [Getting Started guide](https://hardhat.org/docs/getting-started#getting-started-with-hardhat-3). To share your feedback, join our [Hardhat 3 Beta](https://hardhat.org/hardhat3-beta-telegram-group) Telegram group or [open an issue](https://github.com/NomicFoundation/hardhat/issues/new) in our GitHub issue tracker.

## Project Overview

This example project includes:

- A simple Hardhat configuration file.
- Foundry-compatible Solidity unit tests.
- TypeScript integration tests using [`node:test`](nodejs.org/api/test.html), the new Node.js native test runner, and [`viem`](https://viem.sh/).
- Examples demonstrating how to connect to different types of networks, including locally simulating OP mainnet.

## Usage

### Running Tests

To run all the tests in the project, execute the following command:

```shell
npx hardhat test
```

You can also selectively run the Solidity or `node:test` tests:

```shell
npx hardhat test solidity
npx hardhat test nodejs
```

### Make a deployment to Sepolia

This project includes an example Ignition module to deploy the contract. You can deploy this module to a locally simulated chain or to Sepolia.

To run the deployment to a local chain:

```shell
npx hardhat ignition deploy ignition/modules/Counter.ts
```

To run the deployment to Sepolia, you need an account with funds to send the transaction. The provided Hardhat configuration includes a Configuration Variable called `SEPOLIA_PRIVATE_KEY`, which you can use to set the private key of the account you want to use.

You can set the `SEPOLIA_PRIVATE_KEY` variable using the `hardhat-keystore` plugin or by setting it as an environment variable.

To set the `SEPOLIA_PRIVATE_KEY` config variable using `hardhat-keystore`:

```shell
npx hardhat keystore set SEPOLIA_PRIVATE_KEY
```

After setting the variable, you can run the deployment with the Sepolia network:

```shell
npx hardhat ignition deploy --network sepolia ignition/modules/Counter.ts
```

# Structure
```
 artifacts/ -> risultato (artifact) della compilazione, file .json che descrivono il contratto
 contracts/ → directory in cui verranno messi i sorgenti dei contratti (estensione .sol) + test in Solidity (estensione .t.sol)
 ignition/modules/ → directory in cui si trovano i file del modulo Ignition usati per eseguire il deploy dei contratti. Un modulo Ignition è un file TypeScript che permette di specificare cosa va pubblicato.
 test/ → directory in cui verranno messi i sorgenti per il testing dei contratti in Solidity (.t.sol) o TypeScript (.ts)
 hardhat.config.ts → file di configurazione
```

# Test Solidity vs Typescript
```
Solidity:
    Vantaggi:
         Utilizzare lo stesso linguaggio di programmazione.
         Ottimo per la scrittura di test unitari semplici. I test unitari vengono solitamente scritti come testNomeDelTest.
         Test più veloci da eseguire perché vengono eseguiti direttamente sulla EVM invece di richiedere la simulazione
        dell’intera blockchain.
         Prevede funzionalità built-in per test con input random e per la verifica di invarianti.
    Limitazioni:
         Non adatto per testare interazioni complesse.
         L’uso di cheatcodes rende più semplice la scrittura di test, ma aggiunge della «magia» all’interno dei contratti che
        non esiste nelle interazioni reali on-chain.
Typescript:
    Vantaggi:
         Esegue i test tramite una simulazione completa della blockchain. Questo rende l’ambiente di test molto più simile all’esecuzione reale
        dei contratti.
         Il linguaggio è molto più espressivo.
         La scrittura di alcuni test semplici possono risultare molto più prolissa rispetto alla versione Solidity, ma è più scalabile.
         È possibile eseguire i test tramite il framework Node.js abbinato a diverse librerie di connessione ad Ethereum alternative: Ether.js e Viem.
         Simulando l’intera blockchain, permette di testare il comportamento dei contratti attraverso una serie di transazioni o blocchi ed usando
        account diversi.
         Permette di stabile connessioni con elementi off-chain, come ad esempio gli oracoli.
    Limitazioni:
         Più complesso per test semplici.
         Esecuzione di test semplici più lenta.
    
    Per farli in ts:
         Node.js test runner + Viem → note:test
         Viem assertions + plugin hardat-network-helpers
         Viem è una libreria mette a disposizione una serie di moduli leggeri, componibili e type-safe per interfacciarsi con una blockchain EVM. 3 concetti fondamentali: (public, wallet, test) client, transport e chain.
         Hardhat Network helpers è un plugin che mette a disposizione una serie di funzionalità per interagire con la rete blockchain
        simulata
    describe() = gruppo di test correlati, it() = test singolo
```

# Security
```
1. Reentrancy: check-effects-interaction pattern
2. delegatecall: library, do not use low level calls
3. Entropy illusion: VRFs or PREVRANDAO or external oracle
4. Unchecked return value: use transfer rather than send/call + withdrawal pattern
5. Race conditions/Front running: commit-reveal approach
6. DoS: no cycles on dynamic data structures + max limit + withdrawal pattern + ez operations inside cycles
7. Floating point imprecision: msg.value * tokensPerEth / weiPerEth
8. Improper input validation: OpenZeppelin
9. Signature replay attack: nonce
10. External contract referencing: use new keyword
```

# Design patterns
```
1. Factory pattern: need to create multiple instances of similar contracts
2. State machine pattern: manage complex state transactions
3. Proxy pattern: manage updatable contracts
4. Withdrawal pattern: manage withdraws from a contract
5. Check-effects-interaction pattern: general of withdrawal
6. Library pattern: manage and reuse of code between contracts
7. Mutex pattern: recursive calls
8. Emergency Stop pattern: block functionalities after a bug
```

# Commands
```
// Init
npx hardhat --init

// Compile
npx hardhat compile

// Testing
npx hardhat test [solidity]
npm add --save-dev @nomicfoundation/hardhat-viem @nomicfoundation/hardhat-viem-assertions @nomicfoundation/hardhat-node-test-runner @nomicfoundation/hardhat-network-helpers viem
// La lista dei plug-in va aggiunta anche nel file di configurazione di Hardhat (hardhat.config.ts)
npx hardhat test [nodejs]
npx hardhat test --coverage

npx hardhat node    // avvia nodo locale
```
Accounts
========

WARNING: Funds sent on live network to accounts with publicly known private keys WILL BE LOST.

```
// apri un nuovo terminale
npx hardhat ignition deploy ignition/modules/StudentModule.ts --network localhost  // deploy del modulo ignition su rete localhost

// se volessi fare sepolia
npx hardhat keystore set SEPOLIA_RPC_URL
npx hardhat keystore set SEPOLIA_PRIVATE_KEY
npx hardhat ignition deploy ignition/modules/StudentModule.ts --network sepolia
```

# Ciò che ha detto la prof
```
sistema per la registrazione di carriere degli studenti, aggiungendo a voce che andiamo a memorizzare in blockchain per ogni studente (quindi Factory Pattern) un contratto, per ogni studente dentro il contratto avremo: gli insegnamenti, che voti ha preso, quando ha fatto l'esame e così via. 
Specifiche per passare l'esame (che è quello che vogliamo fare) è quello di creare gli smart contracts, di testarli con una copertura del 100% e di fare un'interazione a riga di comando tramite degli script Typescript con la libreria Viem. Quindi avere sia i test che uno script Viem che si connette e che invoca le funzioni per vedere cosa succede. 
Quindi simula, per esempio, il fatto che ci siano un tot di utenti che partecipano ad una lotteria. A un certo punto si invocherà il metodo per estrarre il vincitore. Poi il vincitore invocherà il metodo per esser pagato. Questa è l'idea base del progetto. 
Quindi, senza la necessità di creare delle applicazioni web decentralizzate, semplicemente tutto da riga di comando, creazione degli smart contract, testing, deploy e interazione. 
Deploy che a questo punto, visto che siamo sul puramente testuale lo potete fare anche con il nodo di hardhat, quindi prendendovi gli indirizzi che vi dà hardhat, interagendo con quelli. 
Questo è quello che serve per i crediti del corso. 
```